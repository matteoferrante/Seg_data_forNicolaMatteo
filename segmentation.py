import nibabel as nib
import os
import glob
import numpy as np
import matplotlib.pyplot as plt
from os.path import join as opj
from sklearn.cluster import KMeans
import cc3d
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.pipeline import make_pipeline
from fcmeans import FCM

def compute_prior_center(prior):
        
    """Compute the center of a prior volume.

    Args:
    - prior: 3D numpy array of shape (W, H, D) representing a prior volume
    
    Returns:
    - bar: numpy array of shape (3,) representing the center of the prior volume
    """
    
    bar=np.array(np.where(prior==1)).mean(axis=-1).astype("int")
    return bar


def compute_box_coordinate(bar,half_side):
    
    """
    Compute the coordinates of a bounding box given its center and half side length.

    Args:
    - bar: numpy array of shape (3,) representing the center of the bounding box
    - half_side: scalar representing half the side length of the bounding box
    
    Returns:
    - A tuple (x_min, x_max, y_min, y_max, z_min, z_max) representing the bounding box coordinates.
    """
        
    x_min=bar[0]-half_side
    x_max=bar[0]+half_side

    y_min=bar[1]-half_side
    y_max=bar[1]+half_side

    z_min=bar[2]-half_side
    z_max=bar[2]+half_side
    
    return (x_min,x_max,y_min,y_max,z_min,z_max)


def generate_boxes(img,prior,coord):
    
    """
    Generate a bounding box and its associated prior mask from a larger image and prior volume.

    Args:
    - img: 3D numpy array of shape (W, H, D) representing a larger image
    - prior: 3D numpy array of shape (W, H, D) representing a prior volume
    - coord: tuple (x_min, x_max, y_min, y_max, z_min, z_max) representing the bounding box coordinates
    
    Returns:
    - box: 3D numpy array of shape (W', H', D') representing the bounding box
    - mask_box: 3D numpy array of shape (W', H', D') representing the associated prior mask
    """
    
    x_min,x_max,y_min,y_max,z_min,z_max=coord
    box=img[x_min:x_max,y_min:y_max,z_min:z_max]
    mask_box=prior[x_min:x_max,y_min:y_max,z_min:z_max]
    
    return box,mask_box


def select_cluster_on_prior(pred_mask,box_pos,n_cluster,half_side):
    """
    Select the cluster from a segmentation mask that corresponds to the target object.

    Args:
    - pred_mask: 3D numpy array of shape (W, H, D, 1) representing the segmentation mask
    - box_pos: 2D numpy array of shape (N, 4) representing the bounding boxes and their centers
    - n_cluster: scalar representing the number of clusters in the segmentation mask
    - half_side: scalar representing half the side length of the bounding box
    
    Returns:
    - The index of the cluster that corresponds to the target object, or None if no such cluster exists.
    """
    
    selected=None
    for i in range(n_cluster):
        # print(box_pos[pred_mask[:,:,:,0]==0][:,1:])
        if [half_side,half_side,half_side] in box_pos[pred_mask[:,:,:,0]==i][:,1:].astype("int").tolist():
            selected=i
            break
    return selected

def run_segmentation(img,prior,n_cluster=10,half_side=6):
    
    """The segmentation algorithm works as follows:

        Compute the center of mass of the given prior mask.
        Compute the coordinate range of a box centered on the center of mass with a side length of 2*half_side.
        Generate a sub-image (box) of img and a corresponding sub-mask (mask_box) of prior using the computed coordinate range.
        Flatten the box to a one-dimensional array of pixel values and their corresponding (x, y, z) positions.
        Use K-Means clustering to cluster the pixel values in the box.
        Select the cluster that contains the center point of the box.
        Use connected component analysis to remove small connected components from the binary segmentation mask generated by the K-Means clustering.
        Return the binary segmentation mask with the same shape as the original prior mask. 

        Args:
            - img: 3D numpy array of shape (W, H, D) representing a larger image
            - prior: 3D numpy array of shape (W, H, D) representing a prior volume
            - n_cluster: scalar representing the number of clusters in the segmentation mask
            - half_side: scalar representing half the side length of the bounding box
       Returns:
            - A boolean img in form of 3D numpy array of shape (W,H,D) (same as original image) that is the segmentation
    """         


    
    
    ##compute center of mass
    bar=compute_prior_center(prior)
    
    #compute coordinates
    coord=compute_box_coordinate(bar,half_side)
    x_min,x_max,y_min,y_max,z_min,z_max=coord
    
    #compute box and mask box
    box,mask_box=generate_boxes(img,prior,coord)
    
    size_x, size_y, size_z = box.shape

    # Create one-dimensional arrays representing the indices along each dimension
    indices_x = np.arange(2*half_side)
    indices_y = np.arange(2*half_side)
    indices_z = np.arange(2*half_side)

    # Use numpy.meshgrid() to create a tuple of arrays representing the coordinates of all points in the grid
    grid_x, grid_y, grid_z = np.meshgrid(indices_x, indices_y, indices_z, indexing='ij')

    indices_3d = np.stack((grid_x, grid_y, grid_z), axis=-1)
    
    #concatenate position info
    box_pos=np.concatenate([np.expand_dims(box,-1),indices_3d],axis=-1)
    
    data=box_pos.flatten().reshape(-1,1)
    
    #estimator
    kmeans = KMeans(n_clusters=n_cluster, random_state=0, n_init="auto")
    estimator= make_pipeline(StandardScaler(), kmeans).fit(data)
    
    #predict
    pred_mask=estimator.predict(data).reshape(2*half_side,2*half_side,2*half_side,4)
    
    #get cluster
    cluster_idx=select_cluster_on_prior(pred_mask,box_pos,n_cluster,half_side)
    
    #fix connected compoents
    labels_out = cc3d.connected_components(pred_mask[:,:,:,0]==cluster_idx)
    
    con_idx,con_count=np.unique(labels_out,return_counts=True)
    con_idx=con_idx[1:]
    con_count=con_count[1:]
    labels_out=(labels_out==con_idx[con_count.argmax()])*1.
    
    #fix back image to original dims
    segmentation=np.zeros(prior.shape)
    segmentation[x_min:x_max,y_min:y_max,z_min:z_max]=labels_out
    
    return segmentation




def run_prior_segmentation(img,prior,n_cluster=10,half_side=6,prior_weight=0.5):
        """The segmentation algorithm works as follows:

            Compute the center of mass of the prior using the function compute_prior_center().
            Compute the coordinates of the bounding box around the prior using the function compute_box_coordinate(), with half_side specifying the size of the box.
            Generate the box and a binary mask of the box using the function generate_boxes(), which takes the image, prior, and bounding box coordinates as input.
            Flatten the box and concatenate the flattened position coordinates of each voxel with its index coordinates, creating a 5D tensor where the last dimension has size 3 to represent the position coordinates.
            Scale the data using StandardScaler() and perform fuzzy c-means clustering with n_cluster clusters using the FCM() function from the skfuzzy library to obtain soft labels and centers for each voxel.
            Determine the cluster index that corresponds to the highest probability of belonging to the prior using the function select_cluster_on_prior().
            Increase the probabilities of this cluster within the mask_box by a weight prior_weight using numpy broadcasting and adding this to the soft labels.
            Compute the final segmentation mask by taking the argmax of the soft labels along the last dimension.
            Perform connected component analysis on the binary mask of the predicted cluster and keep the largest component as the final segmentation mask.
            Create a zero array with the same dimensions as the prior and copy the final segmentation mask into the appropriate region of this array as determined by the bounding box coordinates.
            Return the final segmentation mask.

        Args:
            - img: 3D numpy array of shape (W, H, D) representing a larger image
            - prior: 3D numpy array of shape (W, H, D) representing a prior volume
            - n_cluster: scalar representing the number of clusters in the segmentation mask
            - half_side: scalar representing half the side length of the bounding box
       Returns:
            - A boolean img in form of 3D numpy array of shape (W,H,D) (same as original image) that is the segmentation
    """   
    
    
    ##compute center of mass
    bar=compute_prior_center(prior)
    
    #compute coordinates
    coord=compute_box_coordinate(bar,half_side)
    x_min,x_max,y_min,y_max,z_min,z_max=coord
    
    #compute box and mask box
    box,mask_box=generate_boxes(img,prior,coord)
    
    size_x, size_y, size_z = box.shape

    # Create one-dimensional arrays representing the indices along each dimension
    indices_x = np.arange(2*half_side)
    indices_y = np.arange(2*half_side)
    indices_z = np.arange(2*half_side)

    # Use numpy.meshgrid() to create a tuple of arrays representing the coordinates of all points in the grid
    grid_x, grid_y, grid_z = np.meshgrid(indices_x, indices_y, indices_z, indexing='ij')

    indices_3d = np.stack((grid_x, grid_y, grid_z), axis=-1)
    
    #concatenate position info
    box_pos=np.concatenate([np.expand_dims(box,-1),indices_3d],axis=-1)
    
    data=box_pos.flatten().reshape(-1,1)
    
    #estimator
    std=StandardScaler()
    scaled_data=std.fit_transform(data)
    estimator=FCM(n_clusters=n_cluster)
    estimator.fit(scaled_data)
    
    # kmeans = KMeans(n_clusters=n_cluster, random_state=0, n_init="auto")
    # estimator= make_pipeline(StandardScaler(), kmeans).fit(data)
    centers = estimator.centers
    soft_labels = estimator.soft_predict(scaled_data).reshape(2*half_side,2*half_side,2*half_side,4,n_cluster)
    
    #predict
    pred_mask=soft_labels.argmax(axis=-1)
    
    #get cluster
    cluster_idx=select_cluster_on_prior(pred_mask,box_pos,n_cluster,half_side)
    
    #add probabilities
    soft_labels[:,:,:,0,cluster_idx]+=prior_weight*mask_box
    
    #predict final mask
    pred_mask=soft_labels.argmax(axis=-1)
    
    
    #fix connected compoents
    labels_out = cc3d.connected_components(pred_mask[:,:,:,0]==cluster_idx)
    
    con_idx,con_count=np.unique(labels_out,return_counts=True)
    con_idx=con_idx[1:]
    con_count=con_count[1:]
    labels_out=(labels_out==con_idx[con_count.argmax()])*1.
    
    #fix back image to original dims
    segmentation=np.zeros(prior.shape)
    segmentation[x_min:x_max,y_min:y_max,z_min:z_max]=labels_out
    
    return segmentation